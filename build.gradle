import groovy.json.JsonOutput
import groovy.xml.StreamingMarkupBuilder
import groovy.xml.XmlSlurper
import groovy.xml.XmlUtil

buildscript {

	ext {
		localProperties = new Properties()
		def localPropertiesFile = file 'local.properties'
		if (localPropertiesFile.isFile()) {
			localPropertiesFile.withReader { localProperties.load it }
		}
		srcGen = "$buildDir.path/src"
		srcMainGen = "$srcGen/main"
		srcMainAssetsGen = "$srcMainGen/assets"
		srcMainAbiHeadsGen = "$srcMainGen/abiHeads"
		srcMainJniLibsGen = "$srcMainGen/jniLibs"
		addonId = 'plugin.video.elementum'
		addonZip = System.getProperty('addonZip') ?: localProperties.getProperty('addonZip')
		addonDir = addonZip?.with { "$buildDir.path/${file(it).name - ~/\.[^.]+$/}" }
		addonIdDir = addonDir?.with { "$it/$addonId" }
		addonBinDir = addonIdDir?.with { "$it/resources/bin" }
		abiBins = [
				'arm64-v8a'  : 'android_arm64',
				'armeabi-v7a': 'android_arm',
				'x86'        : 'android_x86',
				'x86_64'     : 'android_x64'
		]
		isAddonBinLib = localProperties.getProperty('isAddonBinLib') as Boolean ?: addonBinDir?.with {
			abiBins.any { abi, bin -> !file("$it/$bin/elementum").isFile() }
		} ?: false
		repoUrl = "https://StefanIlchev.github.io/$project.name/"
	}

	repositories {
		google()
		mavenCentral()
		mavenLocal()
		maven { url 'https://jitpack.io' }
	}

	dependencies {
		classpath 'com.android.tools.build:gradle:7.4.2'
	}
}

apply {
	plugin 'com.android.application'
}

allprojects {

	repositories {
		google()
		mavenCentral()
		mavenLocal()
		maven { url 'https://jitpack.io' }
	}

	tasks.withType(JavaCompile).configureEach {
		it.options.deprecation = true
	}
}

android {
	buildToolsVersion = '33.0.2'
	compileSdk 33
	ndkVersion '25.2.9519653'
	namespace 'service.elementum.android'

	compileOptions {
		sourceCompatibility JavaVersion.VERSION_17
		targetCompatibility JavaVersion.VERSION_17
	}

	if (isAddonBinLib) {
		externalNativeBuild {

			cmake {
				version '3.22.1'
				path 'CMakeLists.txt'
			}
		}
	}

	defaultConfig {
		minSdk 26
		targetSdk compileSdk
		versionCode localProperties.getProperty('versionCode') as Integer ?: 53
		versionName localProperties.getProperty('versionName') ?: "$versionCode"
		manifestPlaceholders = [
				'mainIntentAction': 'android.intent.action.MAIN'
		]
		buildConfigField 'String', 'ADDON_ID', "\"$addonId\""
		buildConfigField 'String', 'PROJECT_NAME', "\"$project.name\""
		buildConfigField 'String', 'REPO_URL', "\"$repoUrl\""

		if (isAddonBinLib) {
			externalNativeBuild {

				cmake {
					arguments "-DPROJECT_NAME=$project.name",
							"-DSRC_MAIN_ABI_HEADS_GEN=$srcMainAbiHeadsGen",
							"-DSRC_MAIN_JNI_LIBS_GEN=$srcMainJniLibsGen"
				}
			}
		}
	}

	applicationVariants.configureEach { variant ->
		variant.outputs.each {
			def fileName = it.outputFileName
			def name = fileName - ~/\.[^.]+$/
			it.outputFileName = "$name-$variant.versionName${fileName.substring name.length()}"
		}
	}

	signingConfigs {

		debug {
			storeFile file(localProperties.getProperty('storeFile') ?: 'debug.keystore')
			storePassword localProperties.getProperty('storePassword') ?: 'android'
			keyAlias localProperties.getProperty('keyAlias') ?: 'androiddebugkey'
			keyPassword localProperties.getProperty('keyPassword') ?: 'android'
		}
	}

	buildTypes {

		release {
			minifyEnabled true
			shrinkResources true
			proguardFiles getDefaultProguardFile('proguard-android-optimize.txt')
			signingConfig signingConfigs.debug
		}
	}

	sourceSets {

		main {

			assets {
				srcDir srcMainAssetsGen
			}

			jniLibs {
				srcDir srcMainJniLibsGen
			}
		}
	}

	splits {

		abi {
			enable true
			universalApk true
		}
	}

	packagingOptions {

		jniLibs {
			keepDebugSymbols += '**/lib*.so'
			useLegacyPackaging true
		}
	}
}

dependencies {
	def binaryWrapperProject = subprojects.find { it.path == ':binaryWrapper' }
	if (binaryWrapperProject != null) {
		implementation binaryWrapperProject
	} else {
		implementation localProperties.getProperty('binaryWrapper') ?: 'com.github.StefanIlchev:binaryWrapper:1.0.13'
	}
}

static def toMethodJson(method, params) {
	return JsonOutput.toJson(['jsonrpc': '2.0', 'id': '1', 'method': method, 'params': params])
}

static def toGetAddonDetailsJson(addonId, properties) {
	return toMethodJson('Addons.GetAddonDetails', ['addonid': addonId, 'properties': properties])
}

static def toSetAddonEnabledJson(addonId, enabled) {
	return toMethodJson('Addons.SetAddonEnabled', ['addonid': addonId, 'enabled': enabled])
}

if (addonBinDir != null) {
	def addonVersion = android.defaultConfig.versionName

	def patchAddon = tasks.register('patchAddon') {

		doFirst {
			delete addonDir
		}

		doLast {
			copy {
				from zipTree(addonZip)
				into addonDir
			}
			def repoAddonId = 'repository.elementum'
			def serviceRepoAddonId = 'repository.service.elementum'
			def addonFile = file "$addonIdDir/addon.xml"
			def addonInfo = new XmlSlurper().parse addonFile
			def providerName = addonInfo.@'provider-name'
			addonInfo.@'version' = addonVersion
			addonInfo.'requires'.appendNode {
				'import'('addon': serviceRepoAddonId, 'optional': 'true')
			}
			addonFile.withWriter {
				XmlUtil.serialize(new StreamingMarkupBuilder().bind {
					mkp.yield addonInfo
				}, it)
			}
			def repoAddonInfoFormat = XmlUtil.serialize(new StreamingMarkupBuilder().bind {
				'addon'('name': '{name}', 'id': '{id}', 'provider-name': providerName, 'version': addonVersion) {

					'extension'('name': '{name}', 'point': 'xbmc.addon.repository') {

						'dir' {

							'checksum'("{dataDir}$addonId/addons.xml.md5")

							'datadir'('zip': 'true', '{dataDir}')

							'info'('compressed': 'false', "{dataDir}$addonId/addons.xml")
						}
					}

					'extension'('point': 'xbmc.addon.metadata') {

						'platform'('all')

						'summary'('lang': 'en', '{summary}')
					}

					'requires' {}
				}
			})
			def args = [
					android.namespace,
					android.defaultConfig.manifestPlaceholders['mainIntentAction'],
					'',
			].join ', '
			def stopArgs = "$args, stop:$addonVersion"
			def startArgs = "$args, version:$addonVersion%s"
			def pathPattern = '/org\\.xbmc\\.kodi/'
			def pathReplace = "/$android.namespace/"
			def versionLine = '    installed_version = read_current_version(binary_dir)'
			def versionLinePatched = """    # BEGIN $project.name-patched: version
					|    # installed_version = read_current_version(binary_dir)
					|    installed_version = ADDON_VERSION
					|    binary_dir = ADDON_PATH
					|    dest_binary_dir = binary_dir
					|    binary_path = os.path.join(ADDON_PATH, 'fanart.png')
					|    dest_binary_path = binary_path
					|    # END $project.name-patched: version""".stripMargin()
			def binaryLine = '    return dest_binary_dir, ensure_exec_perms(dest_binary_path)'
			def binaryLinePatched = """    # BEGIN $project.name-patched: binary
					|    # return dest_binary_dir, ensure_exec_perms(dest_binary_path)
					|    return 'N/A', 'N/A'
					|    # END $project.name-patched: binary""".stripMargin()
			def stopLine = '    lockfile = os.path.join(ADDON_PATH, ".lockfile")'
			def stopLinePatched = """    # BEGIN $project.name-patched: stop
					|    # lockfile = os.path.join(ADDON_PATH, ".lockfile")
					|    xbmc.executebuiltin('StartAndroidActivity($stopArgs)')
					|    lockfile = os.path.join(ADDON_PATH, '.lockfile')
					|    if os.path.exists(lockfile):
					|        os.remove(lockfile)
					|    # END $project.name-patched: stop""".stripMargin()
			def startLine = '        proc = subprocess.Popen(args, **kwargs)'
			def startLinePatched = """        # BEGIN $project.name-patched: start
					|        # proc = subprocess.Popen(args, **kwargs)
					|        repoAddonId = '$repoAddonId'
					|        serviceRepoAddonId = '$serviceRepoAddonId'
					|        repoAddonInfoFormat = '''$repoAddonInfoFormat'''
					|        repoAddonInfo = repoAddonInfoFormat.format(
					|            name = 'Elementum Repository',
					|            id = repoAddonId,
					|            dataDir = ELEMENTUMD_HOST + '/repository/$providerName/',
					|            summary = 'GitHub repository for Elementum updates'
					|        )
					|        serviceRepoAddonInfo = repoAddonInfoFormat.format(
					|            name = 'Elementum Service Repository',
					|            id = serviceRepoAddonId,
					|            dataDir = '$repoUrl',
					|            summary = 'GitHub repository for Elementum Service updates'
					|        )
					|        fanartPng = os.path.join(ADDON_PATH, 'fanart.png')
					|        iconPng = os.path.join(ADDON_PATH, 'icon.png')
					|        for id, info in [(repoAddonId, repoAddonInfo), (serviceRepoAddonId, serviceRepoAddonInfo)]:
					|            idDir = os.path.join(ADDON_PATH, '..', id)
					|            infoFile = os.path.join(idDir, 'addon.xml')
					|            if os.path.exists(infoFile):
					|                try:
					|                    with open(infoFile, 'r') as f:
					|                        if info == f.read():
					|                            continue
					|                except Exception:
					|                    pass
					|            try:
					|                shutil.rmtree(idDir, True)
					|                os.makedirs(idDir)
					|                with open(infoFile, 'w') as f:
					|                    f.write(info)
					|                shutil.copy(fanartPng, os.path.join(idDir, 'fanart.png'))
					|                shutil.copy(iconPng, os.path.join(idDir, 'icon.png'))
					|            except Exception:
					|                pass
					|        dataFragment = '%00'.join(six.moves.urllib_parse.quote(arg, '') for arg in args[1:])
					|        dataSuffix = '#' + dataFragment if dataFragment != '' else ''
					|        xbmc.executebuiltin('StartAndroidActivity($startArgs)' % dataSuffix)
					|        for id in [serviceRepoAddonId]:
					|            try:
					|                from elementum.provider import parse_json
					|                detailsJson = '${toGetAddonDetailsJson('%s', ['installed', 'enabled'])}' % id
					|                enableJson = '${toSetAddonEnabledJson('%s', true)}' % id
					|                addon = parse_json(xbmc.executeJSONRPC(detailsJson)) \\
					|                    .get('result', {}).get('addon', {})
					|                if addon.get('installed', False):
					|                    if not addon.get('enabled', False):
					|                        xbmc.executeJSONRPC(enableJson)
					|                    continue
					|                xbmc.executebuiltin('UpdateLocalAddons')
					|                xbmc.executebuiltin('InstallAddon(%s)' % id)
					|                for attempt in range(10):
					|                    addon = parse_json(xbmc.executeJSONRPC(detailsJson)) \\
					|                        .get('result', {}).get('addon', {})
					|                    if addon.get('installed', False):
					|                        break
					|                    time.sleep(1)
					|                xbmc.executeJSONRPC(enableJson)
					|                xbmc.executebuiltin('UpdateLocalAddons')
					|                xbmc.executebuiltin('UpdateAddonRepos')
					|            except Exception:
					|                pass
					|        return None
					|        # END $project.name-patched: start""".stripMargin()
			def retryLine = '            notify(getLocalizedString(30116), time=7000)'
			def retryLinePatched = """            # BEGIN $project.name-patched: retry
					|            # notify(getLocalizedString(30116), time=7000)
					|            args = []
					|            if ADDON.getSetting('local_port') != '':
					|                args.append('-remotePort=' + ADDON.getSetting('local_port'))
					|            if ADDON.getSetting('remote_host') != '':
					|                args.append('-localHost=' + ADDON.getSetting('remote_host'))
					|            if ADDON.getSetting('remote_port') != '':
					|                args.append('-localPort=' + ADDON.getSetting('remote_port'))
					|            dataFragment = '%00'.join(six.moves.urllib_parse.quote(arg, '') for arg in args)
					|            dataSuffix = '#' + dataFragment if dataFragment != '' else ''
					|            xbmc.executebuiltin('StartAndroidActivity($startArgs)' % dataSuffix)
					|            notify(getLocalizedString(30116), time = 7000)
					|            # END $project.name-patched: retry""".stripMargin()
			def infoLine = '        return info'
			def infoLinePatched = """        # BEGIN $project.name-patched: info
					|        # return info
					|        result = {}
					|        for key, value in info.items():
					|            result[key] = re.sub('$pathPattern', '$pathReplace', value, 1)
					|        return result
					|        # END $project.name-patched: info""".stripMargin()
			def translateLine = '        return translatePath(*args, **kwargs)'
			def translateLinePatched = """        # BEGIN $project.name-patched: translate
					|        # return translatePath(*args, **kwargs)
					|        result = translatePath(*args, **kwargs)
					|        return re.sub('$pathPattern', '$pathReplace', result, 1)
					|        # END $project.name-patched: translate""".stripMargin()
			def patches = [
					(file("$addonIdDir/resources/site-packages/elementum/daemon.py"))    : [
							[versionLine, versionLinePatched],
							[binaryLine, binaryLinePatched],
							[stopLine, stopLinePatched],
							[startLine, startLinePatched]
					],
					(file("$addonIdDir/resources/site-packages/elementum/navigation.py")): [
							[retryLine, retryLinePatched]
					],
					(file("$addonIdDir/resources/site-packages/elementum/rpc.py"))       : [
							[infoLine, infoLinePatched],
							[translateLine, translateLinePatched]
					]
			]
			patches.forEach { f, patch ->
				def tmp = file "${f.path}.tmp"
				if (!f.renameTo(tmp)) {
					throw new GradleException(tmp.path)
				}
				copy {
					from f.parent
					into f.parent
					include tmp.name
					rename { f.name }
					filter { line ->
						def index = patch.findIndexOf { it[0] == line }
						index < 0 ? line : patch.removeAt(index)[1]
					}
				}
				if (!patch.isEmpty()) {
					def missing = patch.collect { it.join '\n\n' } join '\n\n\n\n'
					throw new GradleException("$f.path missing:\n$missing")
				}
				delete tmp
			}
		}
	}

	def genMainAssets = tasks.register('genMainAssets') {
		dependsOn patchAddon

		doFirst {
			delete srcMainAssetsGen
		}

		doLast {
			copy {
				from addonDir
				into srcMainAssetsGen
				exclude '**/.*', "$addonId/resources/bin"
			}
		}
	}

	def genMainJniLibs = tasks.register('genMainJniLibs') {
		dependsOn patchAddon

		doFirst {
			delete srcMainAbiHeadsGen, srcMainJniLibsGen
		}

		doLast {
			abiBins.forEach { abi, bin ->
				if (isAddonBinLib) {
					copy {
						from "$addonBinDir/$bin"
						into "$srcMainAbiHeadsGen/$abi"
						include '*.h'
					}
				}
				copy {
					from "$addonBinDir/$bin"
					into "$srcMainJniLibsGen/$abi"
					if (isAddonBinLib) {
						include '*.so'
					} else {
						include 'elementum', 'lib*.so'
					}
					rename { it ==~ /^lib.*\.so$/ ? it : "lib${it}.so" }
				}
			}
		}
	}

	tasks.withType(JavaCompile).configureEach {
		it.dependsOn genMainAssets, genMainJniLibs
	}

	def androidClientZip = file "$buildDir.path/$addonId-${addonVersion}.android_client.zip"

	def zipAndroidClient = tasks.register('zipAndroidClient', Zip) {
		dependsOn patchAddon
		from addonDir
		destinationDirectory = androidClientZip.parentFile
		archiveFileName = androidClientZip.name
		exclude '**/.*', "$addonId/resources/bin"

		doFirst {
			delete androidClientZip
		}
	}

	tasks.register('genPages') {
		dependsOn tasks.named('assembleRelease'), zipAndroidClient
		def pagesDir = "$rootDir.path/docs"

		doFirst {
			delete pagesDir
		}

		doLast {
			def gitignore = file "$rootDir.path/.gitignore"
			def gitignorePages = "!${file(pagesDir).name}/**"
			if (gitignore.isFile() && !gitignore.any { it == gitignorePages }) {
				gitignore.withWriterAppend { it.writeLine gitignorePages }
			}
			copy {
				from "$buildDir.path/outputs/apk/release"
				into pagesDir
				include '*.apk'
			}
			copy {
				from androidClientZip
				into pagesDir
			}
			def repoZip = file "$pagesDir/$addonId/$addonId-${addonVersion}.zip"
			copy {
				from androidClientZip
				into repoZip.parentFile
				rename { repoZip.name }
			}
			def repoInfo = file "$pagesDir/$addonId/addons.xml"
			repoInfo.withWriter {
				XmlUtil.serialize(new StreamingMarkupBuilder().bind {
					'addons' {
						mkp.yield new XmlSlurper().parse(file("$addonIdDir/addon.xml"))
					}
				}, it)
			}
			def repoInfoMd5 = file "$pagesDir/$addonId/addons.xml.md5"
			repoInfoMd5.withWriter {
				it.write repoInfo.text.md5()
			}
			def htmlPage = file "$pagesDir/index.html"
			htmlPage.withWriter {
				def builder = new StreamingMarkupBuilder()
				builder.setUseDoubleQuotes true
				it << '<!DOCTYPE html>' << builder.bind {
					'html'('lang': 'en', 'style': 'color-scheme: light dark;') {

						'head' {

							'meta'('charset': 'utf-8')

							'title'(project.name)
						}

						'body' {

							'table' {
								file(pagesDir).listFiles((FileFilter) { it.isFile() && it != htmlPage }).each {
									def name = XmlUtil.escapeXml it.name
									def date = new Date(it.lastModified()).format 'yyyy-MM-dd HH:mm'
									def size = "${it.length()}B"

									'tr' {

										'td' { 'a'('href': name, name) }

										'td'(date)

										'td'('style': 'text-align: right;', size)
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
