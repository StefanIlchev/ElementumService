buildscript {

	repositories {
		google()
		mavenCentral()
	}

	dependencies {
		classpath 'com.android.tools.build:gradle:7.1.2'
	}
}

apply {
	plugin 'com.android.application'
}

allprojects {

	repositories {
		google()
		mavenCentral()
	}
}

def addonId = 'plugin.video.elementum'
def addonAssetsDir = ".kodi/addons/$addonId"
def remotePort = 65221
def localHost = '127.0.0.1'
def localPort = 65220

def srcGen = "$buildDir.path/src"
def srcMainGen = "$srcGen/main"
def srcMainAssetsGen = "$srcMainGen/assets"
def srcMainJniLibsGen = "$srcMainGen/jniLibs"

android {
	compileSdkVersion 31

	compileOptions {
		sourceCompatibility JavaVersion.VERSION_11
		targetCompatibility JavaVersion.VERSION_11
	}

	defaultConfig {
		minSdkVersion 26
		targetSdkVersion 31
		versionCode System.getProperty('versionCode') as Integer ?: 27
		versionName System.getProperty('versionName') ?: "$versionCode"
		applicationId 'service.elementum.android'
		manifestPlaceholders = [
				'mainIntentAction': 'android.intent.action.MAIN'
		]
		buildConfigField 'java.util.Map<String, String>', 'SUBPROCESS_ASSETS', """
				|java.util.Collections.unmodifiableMap(new java.util.HashMap<>() {{
				|  put("$addonId", "%2\$s/$addonAssetsDir");
				|}})""".stripMargin()
		buildConfigField 'java.util.List<String>', 'SUBPROCESS_CMD', """
				|java.util.Collections.unmodifiableList(java.util.Arrays.asList(
				|    "./libelementum.so",
				|    "-remotePort=$remotePort",
				|    "-localHost=$localHost",
				|    "-localPort=$localPort"
				|))""".stripMargin()
		buildConfigField 'java.util.Map<String, String>', 'SUBPROCESS_ENV', """
				|java.util.Collections.unmodifiableMap(new java.util.HashMap<>() {{
				|  put("LD_LIBRARY_PATH", "%1\$s");
				|}})""".stripMargin()
		buildConfigField 'java.util.Set<Integer>', 'SUBPROCESS_EXIT_VALUES_END', """
				|java.util.Collections.unmodifiableSet(new java.util.HashSet<>(java.util.Arrays.asList(
				|    -9,
				|    1
				|)))""".stripMargin()
		buildConfigField 'java.util.Set<Integer>', 'SUBPROCESS_EXIT_VALUES_SKIP', """
				|java.util.Collections.unmodifiableSet(new java.util.HashSet<>(java.util.Arrays.asList(
				|    -1,
				|    0
				|)))""".stripMargin()
		buildConfigField 'java.util.Set<Integer>', 'SUBPROCESS_EXIT_VALUES_START', """
				|java.util.Collections.unmodifiableSet(new java.util.HashSet<>(java.util.Arrays.asList(
				|    5
				|)))""".stripMargin()
		buildConfigField 'int', 'SUBPROCESS_RETRIES_COUNT', '3'
		buildConfigField 'long', 'SUBPROCESS_RETRY_DELAY', '5_000L'
		buildConfigField 'String', 'SUBPROCESS_TAG', "\"$addonId\""
	}

	applicationVariants.all { variant ->
		variant.outputs.each {
			def fileName = it.outputFileName
			def name = fileName - ~/\.[^.]+$/
			it.outputFileName = "$name-${variant.versionName}${fileName.substring(name.length())}"
		}
	}

	signingConfigs {

		debug {
			storeFile file('debug.keystore')
			storePassword 'android'
			keyAlias 'androiddebugkey'
			keyPassword 'android'
		}
	}

	buildTypes {

		debug {
			manifestPlaceholders = [
					'mainIntentCategory': 'android.intent.category.LAUNCHER'
			]
		}

		release {
			minifyEnabled true
			shrinkResources true
			proguardFiles getDefaultProguardFile('proguard-android-optimize.txt')
			signingConfig signingConfigs.debug
			manifestPlaceholders = [
					'mainIntentCategory': 'android.intent.category.DEFAULT'
			]
		}
	}

	sourceSets {

		main {

			assets {
				srcDir srcMainAssetsGen
			}

			jniLibs {
				srcDir srcMainJniLibsGen
			}
		}
	}

	splits {

		abi {
			enable true
			universalApk true
		}
	}

	packagingOptions {

		jniLibs {
			useLegacyPackaging true
		}
	}
}

def toMethodJson(method, params) {
	return groovy.json.JsonOutput.toJson(['method': method, 'params': params, 'jsonrpc': '2.0', 'id': '1'])
}

def toGetAddonDetailsJson(addonId, properties) {
	return toMethodJson('Addons.GetAddonDetails', ['addonid': addonId, 'properties': properties])
}

def toSetAddonEnabledJson(addonId, enabled) {
	return toMethodJson('Addons.SetAddonEnabled', ['addonid': addonId, 'enabled': enabled])
}

def writeRepoAddon(
		addon,
		addonIdDir,
		repoAddonName,
		repoAddonId,
		repoAddonIdDir,
		repoAddonDataDir,
		repoAddonSummary) {
	copy {
		from addonIdDir
		into repoAddonIdDir
		include 'fanart.png', 'icon.png'
	}
	file("$repoAddonIdDir/addon.xml").withWriter {
		new groovy.xml.MarkupBuilder(it).addon(
				'name': repoAddonName,
				'id': repoAddonId,
				'provider-name': addon.@'provider-name',
				'version': addon.@'version') {

			extension('name': repoAddonName, 'point': 'xbmc.addon.repository') {

				checksum("$repoAddonDataDir${addon.@'id'}/addons.xml.md5")

				datadir('zip': 'true', repoAddonDataDir)

				info('compressed': 'false', "$repoAddonDataDir${addon.@'id'}/addons.xml")
			}

			extension('point': 'xbmc.addon.metadata') {

				platform('all')

				summary('lang': 'en', repoAddonSummary)
			}

			requires {}
		}
	}
}

def addonZip = System.getProperty('addonZip')
if (addonZip != null) {
	def addonDir = "$buildDir.path/${file(addonZip).name - ~/\.[^.]+$/}"
	def addonIdDir = "$addonDir/$addonId"
	def addonVersion = android.defaultConfig.versionName

	def repoAddonName = 'Elementum Repository'
	def repoAddonId = 'repository.elementum'
	def repoAddonIdDir = "$addonIdDir/$repoAddonId"
	def repoAddonDataDir = "http://$localHost:$localPort/repository/elgatito/"
	def repoAddonSummary = 'GitHub repository for Elementum updates'

	def serviceRepoAddonName = 'Elementum Service Repository'
	def serviceRepoAddonId = 'repository.service.elementum'
	def serviceRepoAddonIdDir = "$addonIdDir/$serviceRepoAddonId"
	def serviceRepoAddonDataDir = "https://StefanIlchev.github.io/ElementumService/"
	def serviceRepoAddonSummary = 'GitHub repository for Elementum Service updates'

	task patchAddon() {

		doFirst {
			delete addonDir
		}

		doLast {
			def applicationId = android.defaultConfig.applicationId
			def startArgs = [
					applicationId,
					android.defaultConfig.manifestPlaceholders['mainIntentAction'],
					'',
					"version://$addonVersion"
			]
			def serviceRepoInstalledEnabledJson = toGetAddonDetailsJson(serviceRepoAddonId, ['installed', 'enabled'])
			def serviceRepoEnableJson = toSetAddonEnabledJson(serviceRepoAddonId, true)
			def pathPattern = '/org\\.xbmc\\.kodi/'
			def pathReplace = "/$applicationId/"
			def versionLine = '    installed_version = read_current_version(binary_dir)'
			def versionLinePatched = """
					|    installed_version = ADDON_VERSION
					|    binary_dir = os.path.join(ADDON_PATH, 'resources', 'screenshots')
					|    dest_binary_dir = binary_dir
					|    binary_path = os.path.join(binary_dir, 'home.png')
					|    dest_binary_path = binary_path""".stripMargin()
			def binaryLine = '    return dest_binary_dir, ensure_exec_perms(dest_binary_path)'
			def binaryLinePatched = "    return 'N/A', 'N/A'"
			def startLine = '        return subprocess.Popen(args, **kwargs)'
			def startLinePatched = """
					|        for repoId in ['$repoAddonId', '$serviceRepoAddonId']:
					|            repoDirSrc = os.path.join(ADDON_PATH, repoId)
					|            repoDirDst = os.path.join(ADDON_PATH, '..', repoId)
					|            repoInfoSrc = os.path.join(repoDirSrc, 'addon.xml')
					|            repoInfoDst = os.path.join(repoDirDst, 'addon.xml')
					|            if not os.path.isfile(repoInfoSrc):
					|                continue
					|            try:
					|                if filecmp.cmp(repoInfoSrc, repoInfoDst, shallow=False):
					|                    continue
					|            except Exception:
					|                pass
					|            try:
					|                os.makedirs(repoDirDst)
					|            except Exception:
					|                pass
					|            try:
					|                shutil.rmtree(repoDirDst)
					|            except Exception:
					|                pass
					|            try:
					|                shutil.copytree(repoDirSrc, repoDirDst)
					|            except Exception:
					|                pass
					|        xbmc.executebuiltin('StartAndroidActivity(${startArgs.join(', ')})')
					|        try:
					|            from elementum.provider import parse_json
					|            serviceRepoInstalledEnabledJson = '$serviceRepoInstalledEnabledJson'
					|            serviceRepoEnableJson = '$serviceRepoEnableJson'
					|            addon = parse_json(xbmc.executeJSONRPC(serviceRepoInstalledEnabledJson)) \\
					|                .get('result', {}).get('addon', {})
					|            if addon.get('installed', False):
					|                if not addon.get('enabled', False):
					|                    xbmc.executeJSONRPC(serviceRepoEnableJson)
					|                return False
					|            xbmc.executebuiltin('UpdateLocalAddons')
					|            xbmc.executebuiltin('InstallAddon($serviceRepoAddonId)')
					|            for attempt in range(10):
					|                addon = parse_json(xbmc.executeJSONRPC(serviceRepoInstalledEnabledJson)) \\
					|                    .get('result', {}).get('addon', {})
					|                if addon.get('installed', False):
					|                    break
					|                time.sleep(1)
					|            xbmc.executeJSONRPC(serviceRepoEnableJson)
					|            xbmc.executebuiltin('UpdateLocalAddons')
					|            xbmc.executebuiltin('UpdateAddonRepos')
					|        except Exception:
					|            pass""".stripMargin()
			def pathLine = "        info['path'] = ADDON_PATH"
			def pathLinePatched = """
					|        pathPattern = '$pathPattern'
					|        pathReplace = '$pathReplace'
					|        info['path'] = re.sub(pathPattern, pathReplace, ADDON_PATH, 1)
					|        info['fanart'] = re.sub(pathPattern, pathReplace, info['fanart'], 1)
					|        info['icon'] = re.sub(pathPattern, pathReplace, info['icon'], 1)""".stripMargin()
			def translateLine = '        return translatePath(*args, **kwargs)'
			def translateLinePatched = """
					|        pathPattern = '$pathPattern'
					|        pathReplace = '$pathReplace'
					|        result = translatePath(*args, **kwargs)
					|        return re.sub(pathPattern, pathReplace, result, 1)""".stripMargin()
			def patches = [
					(file("$addonIdDir/resources/site-packages/elementum/daemon.py")): [
							[versionLine, versionLinePatched],
							[binaryLine, binaryLinePatched],
							[startLine, startLinePatched]
					],
					(file("$addonIdDir/resources/site-packages/elementum/rpc.py"))   : [
							[pathLine, pathLinePatched],
							[translateLine, translateLinePatched]
					]
			]
			def renames = new HashSet<>(patches.keySet())
			copy {
				from zipTree(addonZip)
				into addonDir
				rename { renames.removeIf { f -> f.name == it } ? "${it}.tmp" : it }
			}
			if (!renames.isEmpty()) {
				def missing = renames.collect { "$it.path\n" }
				throw new GradleException("missing:\n$missing")
			}
			patches.forEach { f, patch ->
				def tmp = file("${f.parent}/${f.name}.tmp")
				copy {
					from f.parent
					into f.parent
					include tmp.name
					rename { f.name }
					filter {
						def pair = patch.find { pair -> pair[0] == it }
						patch.remove(pair) ? pair[1] : it
					}
				}
				if (!patch.isEmpty()) {
					def missing = patch.collect { it.join '\n\n' } join '\n\n\n\n'
					throw new GradleException("${f.path} missing:\n$missing")
				}
				delete tmp
			}

			def addonFile = file("$addonIdDir/addon.xml")
			def addon = new groovy.xml.XmlSlurper().parse(addonFile)
			addon.@'version' = addonVersion
			addon.requires.appendNode {
				'import'('addon': serviceRepoAddonId, 'optional': 'true')
			}
			addonFile.withWriter {
				groovy.xml.XmlUtil.serialize(new groovy.xml.StreamingMarkupBuilder().bind {
					mkp.yield addon
				}, it)
			}
			writeRepoAddon(
					addon,
					addonIdDir,
					repoAddonName,
					repoAddonId,
					repoAddonIdDir,
					repoAddonDataDir,
					repoAddonSummary)
			writeRepoAddon(
					addon,
					addonIdDir,
					serviceRepoAddonName,
					serviceRepoAddonId,
					serviceRepoAddonIdDir,
					serviceRepoAddonDataDir,
					serviceRepoAddonSummary)
		}
	}

	task genMainAssets(dependsOn: [patchAddon]) {

		doFirst {
			delete srcMainAssetsGen
		}

		doLast {

			copy {
				from addonDir
				into srcMainAssetsGen
				exclude '**/.*', "$addonId/resources/bin", "$addonId/$repoAddonId"
			}
		}
	}

	task genMainJniLibs(dependsOn: [patchAddon]) {

		doFirst {
			delete srcMainJniLibsGen
		}

		doLast {
			[
					'arm64-v8a'  : 'android_arm64',
					'armeabi-v7a': 'android_arm',
					'x86'        : 'android_x86',
					'x86_64'     : 'android_x64'
			].forEach { abi, bin ->
				copy {
					from "$addonIdDir/resources/bin/$bin"
					into "$srcMainJniLibsGen/$abi"
					rename { it ==~ /^lib.*\.so$/ ? it : "lib${it}.so" }
				}
			}
		}
	}

	tasks.withType(JavaCompile) {
		it.dependsOn genMainAssets
		it.dependsOn genMainJniLibs
	}

	def androidClientZip = file("$buildDir.path/$addonId-${addonVersion}.android_client.zip")

	task zipAndroidClient(type: Zip, dependsOn: [patchAddon]) {
		from addonDir
		destinationDirectory = androidClientZip.parentFile
		archiveFileName = androidClientZip.name
		exclude '**/.*', "$addonId/resources/bin"

		doFirst {
			delete androidClientZip
		}
	}

	task genServiceRepo(dependsOn: [patchAddon, zipAndroidClient]) {
		def serviceRepoDir = "$buildDir.path/ElementumService"
		def serviceRepoZip = file("$serviceRepoDir/$addonId/$addonId-${addonVersion}.zip")
		def serviceRepoInfo = file("$serviceRepoDir/$addonId/addons.xml")
		def serviceRepoInfoMd5 = file("$serviceRepoDir/$addonId/addons.xml.md5")

		doFirst {
			delete serviceRepoDir
		}

		doLast {
			copy {
				from androidClientZip
				into serviceRepoZip.parentFile
				rename { serviceRepoZip.name }
			}
			serviceRepoInfo.withWriter {
				groovy.xml.XmlUtil.serialize(new groovy.xml.StreamingMarkupBuilder().bind {
					addons {
						mkp.yield new groovy.xml.XmlSlurper().parse(file("$addonIdDir/addon.xml"))
					}
				}, it)
			}
			serviceRepoInfoMd5.withWriter {
				it.write(serviceRepoInfo.text.md5())
			}
		}
	}
}
