import groovy.json.JsonOutput
import groovy.xml.StreamingMarkupBuilder
import groovy.xml.XmlSlurper
import groovy.xml.XmlUtil

buildscript {

	ext {
		localProperties = new Properties()
		def localPropertiesFile = file 'local.properties'
		if (localPropertiesFile.isFile()) {
			localPropertiesFile.withReader { localProperties.load it }
		}
		srcGen = "$buildDir.path/src"
		srcMainGen = "$srcGen/main"
		srcMainAssetsGen = "$srcMainGen/assets"
		srcMainJniLibsGen = "$srcMainGen/jniLibs"
		addonId = 'plugin.video.elementum'
		addonZip = System.getProperty('addonZip') ?: localProperties.getProperty('addonZip')
		repoUrl = "https://StefanIlchev.github.io/$project.name/"
	}

	repositories {
		google()
		mavenCentral()
		mavenLocal()
		maven { url 'https://jitpack.io' }
	}

	dependencies {
		classpath 'com.android.tools.build:gradle:7.3.1'
	}
}

apply {
	plugin 'com.android.application'
}

allprojects {

	repositories {
		google()
		mavenCentral()
		mavenLocal()
		maven { url 'https://jitpack.io' }
	}

	tasks.withType(JavaCompile).configureEach {
		it.options.deprecation = true
	}
}

android {
	compileSdk 33
	namespace 'service.elementum.android'

	compileOptions {
		sourceCompatibility JavaVersion.VERSION_17
		targetCompatibility JavaVersion.VERSION_17
	}

	defaultConfig {
		minSdk 26
		targetSdk compileSdk
		versionCode localProperties.getProperty('versionCode') as Integer ?: 52
		versionName localProperties.getProperty('versionName') ?: "$versionCode"
		manifestPlaceholders = [
				'mainIntentAction': 'android.intent.action.MAIN'
		]
		buildConfigField 'String', 'ADDON_ID', "\"$addonId\""
		buildConfigField 'String', 'PROJECT_NAME', "\"$project.name\""
		buildConfigField 'String', 'REPO_URL', "\"$repoUrl\""
	}

	applicationVariants.configureEach { variant ->
		variant.outputs.each {
			def fileName = it.outputFileName
			def name = fileName - ~/\.[^.]+$/
			it.outputFileName = "$name-$variant.versionName${fileName.substring name.length()}"
		}
	}

	signingConfigs {

		debug {
			storeFile file(localProperties.getProperty('storeFile') ?: 'debug.keystore')
			storePassword localProperties.getProperty('storePassword') ?: 'android'
			keyAlias localProperties.getProperty('keyAlias') ?: 'androiddebugkey'
			keyPassword localProperties.getProperty('keyPassword') ?: 'android'
		}
	}

	buildTypes {

		release {
			minifyEnabled true
			shrinkResources true
			proguardFiles getDefaultProguardFile('proguard-android-optimize.txt')
			signingConfig signingConfigs.debug
		}
	}

	sourceSets {

		main {

			assets {
				srcDir srcMainAssetsGen
			}

			jniLibs {
				srcDir srcMainJniLibsGen
			}
		}
	}

	splits {

		abi {
			enable true
			universalApk true
		}
	}

	packagingOptions {

		jniLibs {
			keepDebugSymbols += '**/lib*.so'
			useLegacyPackaging true
		}
	}
}

dependencies {
	def binaryWrapperProject = subprojects.find { it.path == ':binaryWrapper' }
	if (binaryWrapperProject != null) {
		implementation binaryWrapperProject
	} else {
		implementation localProperties.getProperty('binaryWrapper') ?: 'com.github.StefanIlchev:binaryWrapper:1.0.12'
	}
}

static def toMethodJson(method, params) {
	return JsonOutput.toJson(['jsonrpc': '2.0', 'id': '1', 'method': method, 'params': params])
}

static def toGetAddonDetailsJson(addonId, properties) {
	return toMethodJson('Addons.GetAddonDetails', ['addonid': addonId, 'properties': properties])
}

static def toSetAddonEnabledJson(addonId, enabled) {
	return toMethodJson('Addons.SetAddonEnabled', ['addonid': addonId, 'enabled': enabled])
}

if (addonZip != null) {
	def addonDir = "$buildDir.path/${file(addonZip).name - ~/\.[^.]+$/}"
	def addonIdDir = "$addonDir/$addonId"
	def addonVersion = android.defaultConfig.versionName

	tasks.register('patchAddon') {

		doFirst {
			delete addonDir
		}

		doLast {
			copy {
				from zipTree(addonZip)
				into addonDir
			}
			def repoAddonId = 'repository.elementum'
			def serviceRepoAddonId = 'repository.service.elementum'
			def addonFile = file "$addonIdDir/addon.xml"
			def addonInfo = new XmlSlurper().parse addonFile
			def providerName = addonInfo.@'provider-name'
			addonInfo.@'version' = addonVersion
			addonInfo.'requires'.appendNode {
				'import'('addon': serviceRepoAddonId, 'optional': 'true')
			}
			addonFile.withWriter {
				XmlUtil.serialize(new StreamingMarkupBuilder().bind {
					mkp.yield addonInfo
				}, it)
			}
			def repoAddonInfoFormat = new StreamingMarkupBuilder().with(true) { builder ->
				builder.setUseDoubleQuotes true
			}.bind {
				'addon'('name': '{name}', 'id': '{id}', 'provider-name': providerName, 'version': addonVersion) {

					'extension'('name': '{name}', 'point': 'xbmc.addon.repository') {

						'dir' {

							'checksum'("{dataDir}$addonId/addons.xml.md5")

							'datadir'('zip': 'true', '{dataDir}')

							'info'('compressed': 'false', "{dataDir}$addonId/addons.xml")
						}
					}

					'extension'('point': 'xbmc.addon.metadata') {

						'platform'('all')

						'summary'('lang': 'en', '{summary}')
					}

					'requires' {}
				}
			}.toString()
			def args = [
					android.namespace,
					android.defaultConfig.manifestPlaceholders['mainIntentAction'],
					'',
			].join ', '
			def stopArgs = "$args, stop:$addonVersion"
			def startArgs = "$args, version:$addonVersion%s"
			def pathPattern = '/org\\.xbmc\\.kodi/'
			def pathReplace = "/$android.namespace/"
			def versionLine = '    installed_version = read_current_version(binary_dir)'
			def versionLinePatched = """    # BEGIN $project.name-patched: version
					|    # installed_version = read_current_version(binary_dir)
					|    installed_version = ADDON_VERSION
					|    binary_dir = ADDON_PATH
					|    dest_binary_dir = binary_dir
					|    binary_path = os.path.join(ADDON_PATH, 'fanart.png')
					|    dest_binary_path = binary_path
					|    # END $project.name-patched: version""".stripMargin()
			def binaryLine = '    return dest_binary_dir, ensure_exec_perms(dest_binary_path)'
			def binaryLinePatched = """    # BEGIN $project.name-patched: binary
					|    # return dest_binary_dir, ensure_exec_perms(dest_binary_path)
					|    return 'N/A', 'N/A'
					|    # END $project.name-patched: binary""".stripMargin()
			def stopLine = '    lockfile = os.path.join(ADDON_PATH, ".lockfile")'
			def stopLinePatched = """    # BEGIN $project.name-patched: stop
					|    # lockfile = os.path.join(ADDON_PATH, ".lockfile")
					|    xbmc.executebuiltin('StartAndroidActivity($stopArgs)')
					|    lockfile = os.path.join(ADDON_PATH, '.lockfile')
					|    if os.path.exists(lockfile):
					|        os.remove(lockfile)
					|    # END $project.name-patched: stop""".stripMargin()
			def startLine = '        return subprocess.Popen(args, **kwargs)'
			def startLinePatched = """        # BEGIN $project.name-patched: start
					|        # return subprocess.Popen(args, **kwargs)
					|        repoAddonId = '$repoAddonId'
					|        serviceRepoAddonId = '$serviceRepoAddonId'
					|        repoAddonInfoFormat = '$repoAddonInfoFormat'
					|        repoAddonInfo = repoAddonInfoFormat.format(
					|            name = 'Elementum Repository',
					|            id = repoAddonId,
					|            dataDir = ELEMENTUMD_HOST + '/repository/$providerName/',
					|            summary = 'GitHub repository for Elementum updates'
					|        )
					|        serviceRepoAddonInfo = repoAddonInfoFormat.format(
					|            name = 'Elementum Service Repository',
					|            id = serviceRepoAddonId,
					|            dataDir = '$repoUrl',
					|            summary = 'GitHub repository for Elementum Service updates'
					|        )
					|        fanartPng = os.path.join(ADDON_PATH, 'fanart.png')
					|        iconPng = os.path.join(ADDON_PATH, 'icon.png')
					|        for id, info in [(repoAddonId, repoAddonInfo), (serviceRepoAddonId, serviceRepoAddonInfo)]:
					|            idDir = os.path.join(ADDON_PATH, '..', id)
					|            infoFile = os.path.join(idDir, 'addon.xml')
					|            if os.path.exists(infoFile):
					|                try:
					|                    with open(infoFile, 'r') as f:
					|                        if info == f.read():
					|                            continue
					|                except Exception:
					|                    pass
					|            try:
					|                shutil.rmtree(idDir, True)
					|                os.makedirs(idDir)
					|                with open(infoFile, 'w') as f:
					|                    f.write(info)
					|                shutil.copy(fanartPng, os.path.join(idDir, 'fanart.png'))
					|                shutil.copy(iconPng, os.path.join(idDir, 'icon.png'))
					|            except Exception:
					|                pass
					|        dataFragment = '%00'.join(six.moves.urllib_parse.quote(arg, '') for arg in args[1:])
					|        dataSuffix = '#' + dataFragment if dataFragment != '' else ''
					|        xbmc.executebuiltin('StartAndroidActivity($startArgs)' % dataSuffix)
					|        for id in [serviceRepoAddonId]:
					|            try:
					|                from elementum.provider import parse_json
					|                detailsJson = '${toGetAddonDetailsJson('%s', ['installed', 'enabled'])}' % id
					|                enableJson = '${toSetAddonEnabledJson('%s', true)}' % id
					|                addon = parse_json(xbmc.executeJSONRPC(detailsJson)) \\
					|                    .get('result', {}).get('addon', {})
					|                if addon.get('installed', False):
					|                    if not addon.get('enabled', False):
					|                        xbmc.executeJSONRPC(enableJson)
					|                    continue
					|                xbmc.executebuiltin('UpdateLocalAddons')
					|                xbmc.executebuiltin('InstallAddon(%s)' % id)
					|                for attempt in range(10):
					|                    addon = parse_json(xbmc.executeJSONRPC(detailsJson)) \\
					|                        .get('result', {}).get('addon', {})
					|                    if addon.get('installed', False):
					|                        break
					|                    time.sleep(1)
					|                xbmc.executeJSONRPC(enableJson)
					|                xbmc.executebuiltin('UpdateLocalAddons')
					|                xbmc.executebuiltin('UpdateAddonRepos')
					|            except Exception:
					|                pass
					|        # END $project.name-patched: start""".stripMargin()
			def retryLine = '            notify(getLocalizedString(30116), time=7000)'
			def retryLinePatched = """            # BEGIN $project.name-patched: retry
					|            # notify(getLocalizedString(30116), time=7000)
					|            args = []
					|            if ADDON.getSetting('local_port') != '':
					|                args.append('-remotePort=' + ADDON.getSetting('local_port'))
					|            if ADDON.getSetting('remote_host') != '':
					|                args.append('-localHost=' + ADDON.getSetting('remote_host'))
					|            if ADDON.getSetting('remote_port') != '':
					|                args.append('-localPort=' + ADDON.getSetting('remote_port'))
					|            dataFragment = '%00'.join(six.moves.urllib_parse.quote(arg, '') for arg in args)
					|            dataSuffix = '#' + dataFragment if dataFragment != '' else ''
					|            xbmc.executebuiltin('StartAndroidActivity($startArgs)' % dataSuffix)
					|            notify(getLocalizedString(30116), time = 7000)
					|            # END $project.name-patched: retry""".stripMargin()
			def infoLine = '        return info'
			def infoLinePatched = """        # BEGIN $project.name-patched: info
					|        # return info
					|        result = {}
					|        for key, value in info.items():
					|            result[key] = re.sub('$pathPattern', '$pathReplace', value, 1)
					|        return result
					|        # END $project.name-patched: info""".stripMargin()
			def translateLine = '        return translatePath(*args, **kwargs)'
			def translateLinePatched = """        # BEGIN $project.name-patched: translate
					|        # return translatePath(*args, **kwargs)
					|        result = translatePath(*args, **kwargs)
					|        return re.sub('$pathPattern', '$pathReplace', result, 1)
					|        # END $project.name-patched: translate""".stripMargin()
			def patches = [
					(file("$addonIdDir/resources/site-packages/elementum/daemon.py"))    : [
							[versionLine, versionLinePatched],
							[binaryLine, binaryLinePatched],
							[stopLine, stopLinePatched],
							[startLine, startLinePatched]
					],
					(file("$addonIdDir/resources/site-packages/elementum/navigation.py")): [
							[retryLine, retryLinePatched]
					],
					(file("$addonIdDir/resources/site-packages/elementum/rpc.py"))       : [
							[infoLine, infoLinePatched],
							[translateLine, translateLinePatched]
					]
			]
			patches.forEach { f, patch ->
				def tmp = file "${f.path}.tmp"
				if (!f.renameTo(tmp)) {
					throw new GradleException(tmp.path)
				}
				copy {
					from f.parent
					into f.parent
					include tmp.name
					rename { f.name }
					filter { line ->
						def index = patch.findIndexOf { it[0] == line }
						index < 0 ? line : patch.removeAt(index)[1]
					}
				}
				if (!patch.isEmpty()) {
					def missing = patch.collect { it.join '\n\n' } join '\n\n\n\n'
					throw new GradleException("$f.path missing:\n$missing")
				}
				delete tmp
			}
		}
	}

	tasks.register('genMainAssets') {
		dependsOn 'patchAddon'

		doFirst {
			delete srcMainAssetsGen
		}

		doLast {
			copy {
				from addonDir
				into srcMainAssetsGen
				exclude '**/.*', "$addonId/resources/bin"
			}
		}
	}

	tasks.register('genMainJniLibs') {
		dependsOn 'patchAddon'

		doFirst {
			delete srcMainJniLibsGen
		}

		doLast {
			[
					'arm64-v8a'  : 'android_arm64',
					'armeabi-v7a': 'android_arm',
					'x86'        : 'android_x86',
					'x86_64'     : 'android_x64'
			].forEach { abi, bin ->
				copy {
					from "$addonIdDir/resources/bin/$bin"
					into "$srcMainJniLibsGen/$abi"
					rename { it ==~ /^lib.*\.so$/ ? it : "lib${it}.so" }
				}
			}
		}
	}

	tasks.withType(JavaCompile).configureEach {
		it.dependsOn 'genMainAssets', 'genMainJniLibs'
	}

	def androidClientZip = file "$buildDir.path/$addonId-${addonVersion}.android_client.zip"

	tasks.register('zipAndroidClient', Zip) {
		dependsOn 'patchAddon'
		from addonDir
		destinationDirectory = androidClientZip.parentFile
		archiveFileName = androidClientZip.name
		exclude '**/.*', "$addonId/resources/bin"

		doFirst {
			delete androidClientZip
		}
	}

	tasks.register('genRepo') {
		dependsOn 'assembleRelease', 'zipAndroidClient'
		def repoDir = "$buildDir.path/$project.name"

		doFirst {
			delete repoDir
		}

		doLast {
			copy {
				from "$buildDir.path/outputs/apk/release"
				into repoDir
				include '*.apk'
			}
			copy {
				from androidClientZip
				into repoDir
			}
			def repoZip = file "$repoDir/$addonId/$addonId-${addonVersion}.zip"
			copy {
				from androidClientZip
				into repoZip.parentFile
				rename { repoZip.name }
			}
			def repoInfo = file "$repoDir/$addonId/addons.xml"
			repoInfo.withWriter {
				XmlUtil.serialize(new StreamingMarkupBuilder().bind {
					'addons' {
						mkp.yield new XmlSlurper().parse(file("$addonIdDir/addon.xml"))
					}
				}, it)
			}
			def repoInfoMd5 = file "$repoDir/$addonId/addons.xml.md5"
			repoInfoMd5.withWriter {
				it.write repoInfo.text.md5()
			}
			def htmlPage = file "$repoDir/index.html"
			htmlPage.withWriter {
				it << '<!DOCTYPE html>' << new StreamingMarkupBuilder().with(true) { builder ->
					builder.setUseDoubleQuotes true
				}.bind {
					'html'('lang': 'en', 'style': 'color-scheme: light dark;') {

						'head' {

							'meta'('charset': 'utf-8')

							'title'(project.name)
						}

						'body' {

							'table' {
								file(repoDir).listFiles((FileFilter) { it.isFile() && it != htmlPage }).each {
									def name = XmlUtil.escapeXml it.name
									def date = new Date(it.lastModified()).format 'yyyy-MM-dd HH:mm'
									def size = "${it.length()}B"

									'tr' {

										'td' { 'a'('href': name, name) }

										'td'(date)

										'td'('style': 'text-align: right;', size)
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
